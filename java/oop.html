<!DOCTYPE html>
<html>
	<head>
        <meta charset="utf-8">
		<title>OOP</title>
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>
	<body>
	<h1>Принципи OOP</h1>
		<p>
			ООП - одна з парадигм програмування, яка розглядає програму як множину «об'єктів», що взаємодіють між собою.
		</p>
		<p>
			Клас - це визначення шаблону методів та змінних у певному виді об'єкта. Об'єкт - екземпляр класу. Має стан і поведінку. Клас -тип, об'єкт-змінна.
		</p>
		<ul>
			<li>Наслідування</li>
			<p>
				 Mеханізм утворення нових класів на основі використання вже існуючих.
			</p>
			<h3>Типи наслідування</h3>
			<ul>
				<li>Single Inheritance</li>
				<img src="images/Single_Inheritance_in_Java.png" >
				<li>Multiple Inheritance (Through Interface)</li>
				<img src="images/Multiple_Inheritance_in_Java.png" >
				<li>Multilevel Inheritance</li>
				<img src="images/Multilevel_Inheritance_in_Java.png" >
				<li>Hierarchical Inheritance</li>
				<img src="images/Hierarchical_Inheritance_in_Java.png" >
				<li>Hybrid Inheritance (Through Interface)</li>
				<img src="images/Hybrid_Inheritance_in_Java.png" >
			</ul>
			<li>Поліморфізм</li>
			<p>
				Kонцепція в програмуванні, відповідно до якої використовується спільний інтерфейс для обробки різних спеціалізованих типів.
			</p>
			<p>
				Polymorphism is the ability of an object to take on many forms. The most common use of polymorphism in OOP occurs when a parent class reference is used to refer to a child class object.
			</p>
			<p>
				Досягається завдяки method overloading( you have more than one method with the same name within the same class but the conditions here is that the parameter which is passed should be different - Static Binding) i method overriding(same method signature in different classes).
			</p>
			<p>
				Dynamic Binding or Late Binding or Runtime Polymorphism<br>
				When the Child class didn’t override the Parent class method as in the above case then the display() method of the Parent will be called.<br>
				the Child class method cannot be called
			</p>
			<p class="code">
				ParentClass  obj2 = new ChildClass();<br>
				// Child Class disp () will be called, as it reference to the child class.<br>
		obj2.disp(); 
			</p>
			<p>Connecting a method call to a method body is called binding. When binding is performed before the program is run, it’s called <em>early binding</em>.<em>Late binding</em> means that the binding occurs at run time, based on the type of object. Late binding is also called dynamic binding or runtime binding.All method binding in Java uses late binding unless the method is static or final (private methods are implicitly final). Constructors are static.The only safe methods to call inside a constructor are those that are final in the base class.</p>
			<p>
				The access modifier of the overriding method(method in the Child class) cannot be more restrictive than the Parent class.
			</p>
			<p>
				When Parent class method doesn’t throw any exception then Child class overriden method can declare UnChecked Exception (Runtime Exception).
When Parent class declares an Exception then the Child class overriden method can declare the same or sub class exception or no exception.
			</p>
			<p>
				You can overload a static method in Java. We cannot overload two methods which differs in static keyword but has the same method signature.
			</p>
				We cannot Override a static method in Java. When the Child class also has defined the same static method like Parent class, the Parent method is called.
			<p>
			</p>
			<li>Інкапсуляція</li>
			<p>
				Принцип, згідно з яким будь-який клас повинен розглядатися як чорний ящик - користувач класу повинен бачити і використовувати тільки інтерфейсну частину класу (тобто список декларованих властивостей і методів класу) і не вникати в його внутрішню реалізацію.
			</p>
			<p>
				Encapsulation in Java is the process of wrapping code and data together into a single unit. 
			</p> 
			<p>Advantages in encapsulation:</p>
			<ul>
				<li>Encapsulation increases the maintianability of the code without any break.</li>
				<li>Provides you the better control over the data, suppose if you want the values which greater than 500 alone to be set, then you can simply write the restriction logic in the setter method.</li>
				<li>You can make the fields read-only or write-only. </li>
			</ul>
			<li>Абстракція</li>
			<p>
				Надання об'єкту характеристик, які відрізняють його від усіх інших об'єктів, чітко визначаючи його концептуальні кордони.
			</p>
			<p>
				Виділення загальних характеристик об'єкта, виключаючи набір незначних. З допомогою цього принципу дані перетворюються в об'єкти. Відділяє реалізацію обєктів від їх деталей. Animal"&lt;-Dog.
			</p>
			<p>
			Abstraction is a process of hiding the implementation details from the user, only the functionality will be provided to the user. In other words, the user will have the information on what the object does instead of how it does it.In Java, abstraction is achieved using Abstract classes(partial abstraction) and interfaces(full abstraction).
			</p>
			<p>
				Abstraction is a process of hiding the implementation details and showing only functionality to the user.
			</p>
			<p>
				A Marker interface is a interface with no variables and methods, in simple words, we can say that empty interface in java is called marker interface (Serializable, Cloneable, Remote ).Used to indicate something to compiler or JVM.  the need for the marker interface is eliminated by the introduction of Java Annotation feature. 
			</p>
			<p>Fields defined in interfaces cannot be "blank finals," but they can be initialized with non-constant expressions.</p>
		</ul>
		<h1>SOLID</h1>
		<table>
		<tr>
			<td>S</td>
			<td>Single responsibility principle</td>
			<td>Кожен об'єкт має виконувати лише один обов'язок.</td>
		</tr>
		<tr>
			<td>O</td>
			<td>Open/closed principle</td>
			<td>Програмні сутності повинні бути відкритими для розширення, але закритими для змін. Розширення певного класу/інтерфейсу може здійснюватись через його успадкування.</td>
		</tr>
		<tr>
			<td>L</td>
			<td>Liskov substitution principle</td>
			<td>Об'єкти в програмі можуть бути заміненими їх нащадками без зміни коду програми.</td>
		</tr>
		<tr>
			<td>I</td>
			<td>Interface segregation principle</td>
			<td>Багато спеціалізованих інтерфейсів краще за один універсальний.</td>
		</tr>
		<tr>
			<td>D</td>
			<td>Dependency inversion principle</td>
			<td>Абстракції не повинні залежати від деталей реалізації. Деталі реалізації повинні залежати від абстракцій.</td>
		</tr>
		</table>
		<p>
		Don’t repeat yourself — DRY.
		</p>
		<h1>Типи зв'язків між об'єктами</h1>
		<img src="images/association-aggregation-composition-100643061-primary.idge.jpg">
		<p>
		П'ять типів зв'язків в UML:
		<ul>
			<li>асоціація</li>
			<p>Існує будь-який зв'язок. Пацієнт - лікар</p>
			<li>агрегація</li>
			<p>"has-a". Група has-a студент.</p>
			<li>композиція</li>
			<p>"is-a". Кімната is-a частина будинку. </p>
			<li>залежність</li>
			<li>успадкування</li>
		</ul>
		</p>
		<p>
			 The <em>is-a</em> relationship is expressed with inheritance, and the <em>has-a</em> relationship is expressed with composition.  
		</p>
		<a href="java_core.html"><img src="images/next.png" width="200px" height="150px"></a>
	</body>
</html>	
