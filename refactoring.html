<!DOCTYPE html>
<html>
<head>
	<title>Refactoring</title>
	<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
	<h1>Composing methods</h1>
	<ul>
		<li>Extract method
			<p>
				You have a code fragment that can be grouped together. Turn the fragment into a method whose name explains the purpose of the method. 
			</p>
		</li>
		<li>Inline method
			<p>Replace all method calls with the body of method and delete method. Use whan too much indirection.</p>
		</li>
		<li>Inline temp</li>
		<li>Replace temp with query
			<p>You are using a temporary variable to hold the result of an expression. Extract the expression into a method. Replace all references to the temp with the expression. The new method can then be used in other methods.</p>
		</li>
		<li>Introduce explaining variable
			<p>Put the result of the expression, or parts of the expression, in a temporary variable with a name that explains the purpose. Usually can be replaced with Extract method.</p>
		</li>
		<li>Split Temporary Variable 
			<p>
				You have a temporary variable assigned to more than once, but is not a loop variable nor a collecting temporary variable. Make a separate temporary variable for each assignment. 
			</p>
			<code> i = i + some expression // collecting variable</code>
		</li>
		<li>Remove Assignments to Parameters
			<p>
				<img src="images/no_par_assign.png">
			</p>
			<p>Pass by value and pass by reference problem.</p>
		</li>
		<li>Replace method with method object
			<p>
				You have a long method that uses local variables in such a way that you cannot apply Extract Method. Turn the method into its own object so that all the local variables become fields on that object. You can then decompose the method into other methods on the same object. Give the new class a final field for the object that hosted the original method and constructor that receives this object. 
			</p>
		</li>
		<li>Substitute Algorithm
			<p>Replace the body of the method with the new clearer algorithm.</p>
		</li>
	</ul>
	<h1>Moving features between objects</h1>
	<ul>
		<li>Move method
			<p>A method is using more features of another class than the class on which it is defined. </p>
		</li>
		<li>Move Field 
			<p>
				A field is used by another class more than the class on which it is defined. 		
			</p>
		</li>
		<li>Extract class
			<p>You have one class doing work that should be done by two. </p>
		</li>
		<li>Inline Class 
			<p>A class isn't doing very much.</p>
		</li>
		<li>Hide Delegate 
			<p>A client is calling a delegate class of an object. Create methods on the server to hide the delegate. Motivation - advantages of encapsulation.</p>
			<p><img src="images/hide_deleg.png"></p>
		</li>
		<li>Remove middle man
			<p>Opposite to hide delegate. Motivation - too much methods are delegated.</p>
		</li>
		<li>Introduce foreign method
			<p>A server class you are using needs an additional method, but you can't modify the class. </p>
			<p><img src="images/intr_foreign_method.png"></p>
		</li>
		<li>Introduce local extension
			<p>A server class you are using needs several additional methods, but you can't modify the class. Create a new class that contains these extra methods. Make this extension class a subclass or a wrapper of the original. </p>
		</li>
	</ul>
	<h1>Organizing data</h1>
	<ul>
		<li>Self encapsulate field
			<p><img src="images/self_enc_field.png"></p>
		</li>
		<li>Replace data value with object
			<p><img src="images/repl_data_value.png"></p>
		</li>
		<li style="color: red;">Change value to reference</li>
		<li style="color: red;">Change reference to value</li>
		<li>Replace array with object
			<p><img src="images/repl_arr_obj.png"></p>
		</li>
		<li style="color: red;">Duplicate Observed Data
			<p></p> 
		</li>
		<li style="color: red;">Change Unidirectional Association to Bidirectional </li>
		<li style="color: red;">Change Bidirectional Association to Unidirectional </li>
		<li style="color: red;">Replace Magic Number with Symbolic Constant </li>
		<li>Encapsulate Field 
			<p>Make public field private and provide accessors. </p>
		</li>
		<li>Encapsulate Collection 
			<p>Method returns a collection. Provided methods:
				<ol>
					<li>Getter should return read-only for collection</li>
					<li>Method that adds element to collection</li>
					<li>Method that removes element from collection</li>
				</ol>
			</p>
		</li>
		<li>Replace Record with Data Class
			<p>Make a dumb data object for the record.</p>
		</li>
		<li>Replace Type Code with Class
			<p>A class has a numeric type code that does not affect its behavior. Replace the number with a new class.</p>
			<p><img src="images/repl_type_class.png"></p>
		</li>
		<li>Replace Type Code with Subclasses
			<p>You have an immutable type code that affects the behavior of a class. Replace the type code with subclasses.</p>
			<p><img src="images/repl_type_subclass.png"></p>
		</li>
		<li>Replace Type Code with State/Strategy
			<p>You have a type code that affects the behavior of a class, but you cannot use subclassing. For example,  the value of the type code changes after the object is created or the class with the type code is already subclassed for another reason.</p>
			<p><img src="images/repl_type_state.png"></p>
		</li>
		<li>Replace Subclass with Fields
			<p>You have subclasses that vary only in methods that return constant data. Change the methods to superclass fields and eliminate the subclasses.</p>
			<p><img src="images/repl_subclass_fields.png"></p>
		</li>
	</ul>
	<h1>Simplifying Conditional Expressions</h1>
	<ul>
		<li>Decompose Conditional 
			<p>You have a complicated conditional (if-then-else) statement. Extract methods from the condition, then part, and else parts. </p>
		</li>
		<li>Consolidate Conditional Expression 
			<p>You have a sequence of conditional tests with the same result. Combine them into a single conditional expression and extract it. </p>
		</li>
		<li>Consolidate Duplicate Conditional Fragments 
			<p>The same fragment of code is in all branches of a conditional expression. Move it outside of the expression. </p>
		</li>
		<li>Remove Control Flag 
			<p>You have a variable that is acting as a control flag for a series of boolean expressions. Use a break or return instead. </p>
		</li>
		<li>Replace Nested Conditional with Guard Clauses 
			<p><img src="images/repl_nested_cond.png"></p>
		</li>
		<li>Replace Conditional with Polymorphism 
			<p><img src="images/repl_cond_polymorphism.png"></p>
		</li>
		<li>Introduce Null Object 
			<p>You have repeated checks for a null value. Replace the null value with a null object. Null objects are always constant: nothing about them ever changes (Singleton pattern). Move conditional behaviour inside null object. </p>
			<p><img src="images/repl_null_check.png"></p>
		</li>
		<li>Introduce Assertion 
			<p>A section of code assumes something about the state of the program. Make the assumption explicit with an assertion. </p>
			<p>An assertion is a conditional statement that is assumed to be always true. Failure of an assertion indicates programmer error. </p>
		</li>
	</ul>
	<h1> Making Method Calls Simpler </h1>
	<ul>
		<li>Rename method</li>
		<li>Add parameter</li>
		<li>Remove parameter</li>
		<li>Separate Query from Modifier
			<p>You have a method that returns a value but also changes the state of an object. Create two methods, one for the query and one for the modification. </p>
		</li>
		<li>Parameterize Method
			<p><img src="images/param_method.png"></p>
		</li>
		<li>Replace Parameter with Explicit Methods 
			<p><img src="images/repl_par_with_method.png"></p>
		</li>
		<li>Preserve Whole Object 
			<p>You are getting several values from an object and passing these values as parameters in a method call. Send the whole object instead. </p>
		</li>
		<li>Replace Parameter with Method 
			<p>An object invokes a method, then passes the result as a parameter for a method. The receiver can also invoke this method. Remove the parameter and let the receiver invoke the method. </p>
		</li>
		<li>Introduce Parameter Object 
			<p>You have a group of parameters that naturally go together. Replace them with an object. </p>
			<p><img src="images/intr_par_obj.png"></p>
		</li>
		<li>Remove Setting Method 
			<p>A field should be set at creation time and never altered. Remove any setting method for that field. </p>
		</li>
		<li>Hide Method 
			<p>A method is not used by any other class. Make the method private. </p>
		</li>
		<li>Replace Constructor with Factory Method 
			<p><img src="images/repl_with_factory.png"></p>
		</li>
		<li>Encapsulate Downcast 
			<p>A method returns an object that needs to be downcasted by its callers. Move the downcast to within the method. </p>
		</li>
		<li>Replace Error Code with Exception 
			<p><img src="images/repl_code_exception.png"></p>
		</li>
		<li>Replace Exception with Test 
			<p><img src="images/repl_exc_test.png"></p>
		</li>
	</ul>
	<h1> Dealing with Generalization </h1>
	<ul>
		<li>Pull Up Field 
			<p>Two subclasses have the same field. Move the field to the superclass. </p>
		</li>
		<li>Pull Up Method </li>
		<li>Pull Up Constructor Body</li>
		<li>Push Down Method 
			<p>Behavior on a superclass is relevant only for some of its subclasses. Move it to those subclasses. </p>
		</li>
		<li>Push Down Field </li>
		<li>Extract Subclass 
			<p>A class has features that are used only in some instances. Create a subclass for that subset of features. </p>
		</li>
		<li>Extract Superclass 
			<p>You have two classes with similar features. Create a superclass and move the common features to the superclass.</p>
		</li>
		<li>Extract Interface 
			<p>Several clients use the same subset of a class's interface, or two classes have part of their interfaces in common. Extract the subset into an interface. </p>
		</li>
		<li>Collapse Hierarchy
			<p>A superclass and subclass are not very different. Merge them together. </p>
		</li>
		<li style='color: red;'>Form Template Method</li>
		<li>Replace Inheritance with Delegation 
			<p>A subclass uses only part of a superclasses interface or does not want to inherit data. Create a field for the superclass, adjust methods to delegate to the superclass, and remove the subclassing.  
 			</p>
 			<p>Delegation:<br>
 				<code>class MainClass{<br>
 					&emsp;&emsp;DelegateClass delegateClass;<br>
 					&emsp;&emsp;...<br>
 					&emsp;&emsp;int someMethod(){<br>
 					&emsp;&emsp;&emsp;&emsp;return delegateClass.getValue();<br>
 					&emsp;&emsp;}<br>
 				}
 				</code>
 			</p>
		</li>
		<li>Replace Delegation with Inheritance 
			<p>
				You're using delegation and are often writing many simple delegations for the entire interface. Make the delegating class a subclass of the delegate. 				
			</p>
		</li> 
	</ul>
</body>
</html>